buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.github.jengelman.gradle.plugins:shadow:6.1.0'
        classpath 'org.ajoberstar:gradle-git-publish:2.1.3'
        classpath 'org.ajoberstar:grgit:2.3.0'
    }
}

allprojects {
    repositories {
        jcenter()
        mavenCentral()
    }
}

apply from: "$rootDir/gradle-scripts/git-publish.gradle"
apply from: "$rootDir/gradle-scripts/set-library-version.gradle"
def depVersions = [
        //all
        commercetoolsSdkJvm: '1.64.0',
        logStashLogbackEncoder: '6.6',
        logbackClassic: '1.2.4',
        julToSlf4j: '1.7.32',
        apacheHttp: '4.5.13',

        // :service
        sparkCore: '2.9.3',
        jUnit: '4.13.2',
        assertJ: '3.20.2',
        mockito: '3.11.2',
        caffeine: '2.9.0',
        jackson: '2.12.1',

        // to avoid security vulnerabilities for underlying dependencies within jvm-sdk
        jetty: '9.4.41.v20210516',
        commons : '2.10.0',
        commonsCodec : '1.15'

]


subprojects {
    apply plugin: 'java'

    group = 'com.commercetools'

    // version template. Note:
    // 1) this value overridden in version-resolver.gradle
    // 2) the actual (overridden) value is embed to shadowJar.manifest.Implementation-Version
    // and then at runtime fetched as getImplementationVersion()
    version = '2.9.0-dev'

    sourceCompatibility = '1.8'
    targetCompatibility = '1.8'

    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
    }

    dependencies {
        constraints {
            implementation "commons-io:commons-io:${depVersions.commons}"
            implementation "commons-codec:commons-codec:${depVersions.commonsCodec}"
        }
        implementation "com.github.ben-manes.caffeine:caffeine:${depVersions.caffeine}"
        implementation "com.commercetools.sdk.jvm.core:commercetools-java-client:${depVersions.commercetoolsSdkJvm}"
        implementation "com.commercetools.sdk.jvm.core:commercetools-models:${depVersions.commercetoolsSdkJvm}"
        implementation "com.commercetools.sdk.jvm.core:commercetools-convenience:${depVersions.commercetoolsSdkJvm}"
        implementation "net.logstash.logback:logstash-logback-encoder:${depVersions.logStashLogbackEncoder}"
        implementation "ch.qos.logback:logback-classic:${depVersions.logbackClassic}"
        implementation "ch.qos.logback:logback-access:${depVersions.logbackClassic}"
        implementation "org.slf4j:jul-to-slf4j:${depVersions.julToSlf4j}"
        implementation "org.apache.httpcomponents:httpclient:${depVersions.apacheHttp}"
    }
}

project(":service") {
    apply plugin: 'com.github.johnrengelman.shadow'
    apply plugin: 'application' // allow "run" task to build and run the app

    // patch project.version with git tag/commit name (if any)
    apply from: "$rootDir/gradle-scripts/version-resolver.gradle"

    // required property for application plugin
    mainClassName = 'com.commercetools.Main'

    dependencies {
        implementation "com.sparkjava:spark-core:${depVersions.sparkCore}"
        constraints {
            implementation "org.eclipse.jetty:jetty-io:${depVersions.jetty}"
            implementation "org.eclipse.jetty:jetty-server:${depVersions.jetty}"
            implementation "org.eclipse.jetty:jetty-webapp:${depVersions.jetty}"
        }
        testImplementation "junit:junit:${depVersions.jUnit}"
        testImplementation "org.assertj:assertj-core:${depVersions.assertJ}"
        testImplementation "org.mockito:mockito-core:${depVersions.mockito}"
        testImplementation "org.mockito:mockito-inline:${depVersions.mockito}"
    }

    shadowJar {
        archiveBaseName.set(rootProject.name)
        archiveClassifier.set(null)
        version = null
        mainClassName = project.mainClassName

        manifest {
            // set version to define at runtime using getImplementationVersion()
            attributes 'Implementation-Title': rootProject.name
            attributes 'Implementation-Version': project.version
        }

        doLast {
            println "Packaged JAR to ${destinationDirectory.getAsFile().getOrNull()}/${archiveFileName.getOrNull()}"
        }
    }

    run {
        description 'Use this task to run the service locally using gradle.properties settings'
        dependsOn ':service:convertGradlePropertiesToJvmArgs'
    }

    runShadow {
        description 'Use this task to run the service locally using gradle.properties settings and ' +
                'include all manifest info specified in \'shadowJar\' configuration'
        dependsOn ':service:convertGradlePropertiesToJvmArgs'
    }

    task convertGradlePropertiesToJvmArgs (type:Task) {
        description 'Convert the gradle build properties (set in gradle.properties) ' +
                    'to JVM runtime properties (-Dkey=value arguments)'

        doLast {
            applicationDefaultJvmArgs = getServiceProperties(project)
        }
    }

    test {
        testLogging {
            // set options for log level LIFECYCLE
            events "passed", "skipped", "failed"
            displayGranularity 2
            exceptionFormat "full"
            showCauses true
            showExceptions true
            showStackTraces true
            maxGranularity 3
            minGranularity 0
        }
    }
}

/**
 * Convert the list of application specific properties from gradle build properties (<i>~/.gradle/gradle.properties</i>)
 * or environment variables to java runtime properties (supplied as <b>-Dkey=value</b> arguments).
 * <p>
 *     The converting is used to provide easy local service run/debug: the developer specifies properties in local
 *     {@code gradle.properties} and easily runs {@code ./gradlew run} task, which is provided by gradle
 *     <i>application</i> plugin. Also in IDE you could run directly gradle <i>run</i> task in debug mode.
 * <p>
 *     The function tries to find a property value from the {@code project} properties and then from environment variables.
 *     If neither of them exists - the property mapping is skipped.
 * <p>
 *     Also this function tries to parse {@code TENANTS} property and later maps <b>all</b> available values which have
 *     property name starting string with tenant name.
 *
 * @param project gradle project from which to take the properties
 * @return a list of java runtime argument in <i>-Dkey=value</i> syntax.
 *
 */
static List<String> getServiceProperties(Project project) {
    def commonProperties = [
            'TENANTS'
    ]

    def tenantsString = findValueByName(project, 'TENANTS')?.trim()

    // try to map all tenant-specific properties (e.g., prefixed by tenant name) from project.properties or System.getenv() set
    if (tenantsString) {
        def tenantsList = tenantsString.split("\\s*,\\s*") // split and trim

        // merge and filter all properties prefixed by a tenant name
        def tenantsProperties = (project.properties.keySet() + System.getenv().keySet()).findAll { property ->
            tenantsList.any {tenantName -> property.startsWith(tenantName)}
        }

        commonProperties.addAll(tenantsProperties)
    }

    def mappedCommonProperties = commonProperties.collect { propertyKey ->
        def propertyValue = findValueByName(project, propertyKey)
        if (propertyValue != null) {
            return "-D${propertyKey}=${propertyValue}"
        }
        return null
    }.grep() // filter out null (empty) properties

    return mappedCommonProperties
}

/**
 * Try to find a property value by name/key in the project properties (e.g. gradle runtime arguments) or
 * environment variables. If property not found - <b>null</b> is returned.
 * @param project project (aka map) where to search the property
 * @param propertyKey property name/key
 * @return property value or <b>null</b> if not found.
 */
static String findValueByName(Project project, String propertyKey) {
    return project.hasProperty(propertyKey) ? (String) project[propertyKey] : System.getenv(propertyKey)
}

task stage {
    description 'This task generates the service jar including all dependencies.'
    dependsOn ':service:shadowJar'
}

task ciBuild {
    description 'This task is run by Travis. It builds the service and runs its unit tests.'
    dependsOn ':service:test'
}

task clean {
    description 'By default :clean is executed only for :service, ' +
            'thus we add cleaning for root build dir'
    dependsOn ':service:clean'
    doLast {
        rootProject.buildDir.deleteDir()
    }
}

